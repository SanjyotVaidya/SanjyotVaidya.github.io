<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://sanjyotvaidya.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://sanjyotvaidya.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-09-03T12:16:00+00:00</updated><id>https://sanjyotvaidya.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Branch Prediction Customization with GCC</title><link href="https://sanjyotvaidya.github.io/blog/2024/Customization-of-branch-prediction-in-GCC/" rel="alternate" type="text/html" title="Branch Prediction Customization with GCC"/><published>2024-08-18T00:00:00+00:00</published><updated>2024-08-18T00:00:00+00:00</updated><id>https://sanjyotvaidya.github.io/blog/2024/Customization-of-branch-prediction-in-GCC</id><content type="html" xml:base="https://sanjyotvaidya.github.io/blog/2024/Customization-of-branch-prediction-in-GCC/"><![CDATA[<h2 id="what-is-branch-prediction-in-computer-architecture">What is branch prediction in computer architecture?</h2> <p>Pipelining is an implementation technique which overlaps multiple instructions in execution. It takes advantage of parallelism that exists among the actions needed to execute an instruction. All processors use pipelining to overlap instructions to improve performance.</p> <p>Every instruction in RISC architecture can be executed in at most 5 clock cycles. These cycles are :</p> <p>For simplicity, let’s consider implementation of RISC instruction set for understanding the pipelining. Every instruction in RISC set is implemented in at most 5 clock cycles. Which are, fetch, decode, execute, memory access and write back.</p> <p>Simple 5 stage risc pipeline can be seen as below:</p> <ol> <li>Instruction Fetch</li> <li>Instruction Decode</li> <li>Execute</li> <li>Memory Access</li> <li>Write Back</li> </ol> <p>This can be implemented in pipelining architecture as below:</p> <p>But what happens when there is if else branch? In such cases CPU tries to do the prediction on which branch to take in order to execute the branch.</p> <table> <thead> <tr> <th style="text-align: left">Instruction number</th> <th style="text-align: center">Clock 1</th> <th style="text-align: center">Clock 2</th> <th style="text-align: center">Clock 3</th> <th style="text-align: center">Clock 4</th> <th style="text-align: center">Clock 5</th> <th style="text-align: center">Clock 6</th> <th style="text-align: center">Clock 7</th> <th style="text-align: center">Clock 8</th> <th style="text-align: center">Clock 9</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">Instruction i</td> <td style="text-align: center">IF</td> <td style="text-align: center">ID</td> <td style="text-align: center">EX</td> <td style="text-align: center">MEM</td> <td style="text-align: center">WB</td> <td style="text-align: center"> </td> <td style="text-align: center"> </td> <td style="text-align: center"> </td> <td style="text-align: center"> </td> </tr> <tr> <td style="text-align: left">Instruction i+1</td> <td style="text-align: center"> </td> <td style="text-align: center">IF</td> <td style="text-align: center">ID</td> <td style="text-align: center">EX</td> <td style="text-align: center">MEM</td> <td style="text-align: center">WB</td> <td style="text-align: center"> </td> <td style="text-align: center"> </td> <td style="text-align: center"> </td> </tr> <tr> <td style="text-align: left">Instruction i+2</td> <td style="text-align: center"> </td> <td style="text-align: center"> </td> <td style="text-align: center">IF</td> <td style="text-align: center">ID</td> <td style="text-align: center">EX</td> <td style="text-align: center">MEM</td> <td style="text-align: center">WB</td> <td style="text-align: center"> </td> <td style="text-align: center"> </td> </tr> <tr> <td style="text-align: left">Instruction i+3</td> <td style="text-align: center"> </td> <td style="text-align: center"> </td> <td style="text-align: center"> </td> <td style="text-align: center">IF</td> <td style="text-align: center">ID</td> <td style="text-align: center">EX</td> <td style="text-align: center">MEM</td> <td style="text-align: center">WB</td> <td style="text-align: center"> </td> </tr> <tr> <td style="text-align: left">Instruction i+4</td> <td style="text-align: center"> </td> <td style="text-align: center"> </td> <td style="text-align: center"> </td> <td style="text-align: center"> </td> <td style="text-align: center">IF</td> <td style="text-align: center">ID</td> <td style="text-align: center">EX</td> <td style="text-align: center">MEM</td> <td style="text-align: center">WB</td> </tr> </tbody> </table> <p>But there are few limitations to this approach. One of such limitation comes while handling branches and control statements. In control statements, the program counter can jump and instruction in pipeline can no longer be valid. If the pipeline flushes, then the instruction will take more cycles for instructions to execute.</p> <p>To avoid this pipeline flush compiler uses optimization techniques to predict which instruction the branch will take.</p> <p>There are several ways by which compiler predicts these instructions. One of such example is likey and unlikely instruction.</p> <h2 id="likely-and-unlikely-instructions">Likely and Unlikely Instructions</h2> <p>Likely and unlikely instructions help processor decide which branch is likely to happen and thus reduces the pipeline flushes.</p> <p>To test this, here is one example of the code:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)
</span>
<span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">num</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">num</span><span class="o">*</span><span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">square_likely</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">num</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">num</span><span class="o">*</span><span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
 	<span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">i</span><span class="o">=</span><span class="n">square</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
	<span class="n">i</span><span class="o">=</span><span class="n">square_likely</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>


<span class="p">}</span>
</code></pre></div></div> <p>In above code, <code class="language-plaintext highlighter-rouge">likely</code> and <code class="language-plaintext highlighter-rouge">unlikely</code> keywords are defined by using <code class="language-plaintext highlighter-rouge">__builtin_expect</code>.</p> <p>The assembly code on x86-64 (AMD64) architecture was as follows:</p> <pre><code class="language-assembly">test_likely.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;square&gt;:
   0:	f3 0f 1e fa          	endbr64
   4:	31 c0                	xor    %eax,%eax
   6:	85 ff                	test   %edi,%edi
   8:	78 05                	js     f &lt;square+0xf&gt;
   a:	89 f8                	mov    %edi,%eax
   c:	0f af c7             	imul   %edi,%eax
   f:	c3                   	ret

0000000000000010 &lt;square_likely&gt;:
  10:	f3 0f 1e fa          	endbr64
  14:	89 f8                	mov    %edi,%eax
  16:	85 ff                	test   %edi,%edi
  18:	78 06                	js     20 &lt;square_likely+0x10&gt;
  1a:	0f af c7             	imul   %edi,%eax
  1d:	c3                   	ret
  1e:	66 90                	xchg   %ax,%ax
  20:	31 c0                	xor    %eax,%eax
  22:	c3                   	ret

Disassembly of section .text.startup:

0000000000000000 &lt;main&gt;:
   0:	f3 0f 1e fa          	endbr64
   4:	53                   	push   %rbx
   5:	48 8d 1d 00 00 00 00 	lea    0x0(%rip),%rbx        # c &lt;main+0xc&gt;
			8: R_X86_64_PC32	.LC0-0x4
   c:	31 d2                	xor    %edx,%edx
   e:	bf 02 00 00 00       	mov    $0x2,%edi
  13:	48 89 de             	mov    %rbx,%rsi
  16:	31 c0                	xor    %eax,%eax
  18:	e8 00 00 00 00       	call   1d &lt;main+0x1d&gt;
			19: R_X86_64_PLT32	__printf_chk-0x4
  1d:	48 89 de             	mov    %rbx,%rsi
  20:	31 d2                	xor    %edx,%edx
  22:	bf 02 00 00 00       	mov    $0x2,%edi
  27:	31 c0                	xor    %eax,%eax
  29:	e8 00 00 00 00       	call   2e &lt;main+0x2e&gt;
			2a: R_X86_64_PLT32	__printf_chk-0x4
  2e:	31 c0                	xor    %eax,%eax
  30:	5b                   	pop    %rbx
  31:	c3                   	ret
</code></pre> <p>Here the function square was using simple <code class="language-plaintext highlighter-rouge">if</code> branch, but function square_likely was using <code class="language-plaintext highlighter-rouge">if</code> with <code class="language-plaintext highlighter-rouge">unlikely</code>. We can see the difference in instruction <code class="language-plaintext highlighter-rouge">xor %eax,%eax</code>. This instruction assigns flushes the eax register, thus return value can be 0. This instruction in <code class="language-plaintext highlighter-rouge">square</code> function is on the line 3, where as it’s on the second last line if we use <code class="language-plaintext highlighter-rouge">unlikely</code>.</p> <p>Similarly another example we can consider:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span>
<span class="cp">#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)
</span>
<span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">num</span><span class="o">*</span><span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">square</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span><span class="o">%</span><span class="mi">100</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"value of i %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">"returning now</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Here if we use condition as <code class="language-plaintext highlighter-rouge">if(i)</code> the assembly generated in Arm architecture is:</p> <pre><code class="language-assembly">
test_likely.o:	file format mach-o arm64

Disassembly of section __TEXT,__text:

0000000000000000 &lt;ltmp0&gt;:
       0: 1b007c00     	mul	w0, w0, w0
       4: d65f03c0     	ret

0000000000000008 &lt;_main&gt;:
       8: d10083ff     	sub	sp, sp, #32
       c: a9017bfd     	stp	x29, x30, [sp, #16]
      10: 910043fd     	add	x29, sp, #16
      14: d2800000     	mov	x0, #0
      18: 94000000     	bl	0x18 &lt;_main+0x10&gt;
		0000000000000018:  ARM64_RELOC_BRANCH26	_time
      1c: d29ae168     	mov	x8, #55051
      20: f2ae1468     	movk	x8, #28835, lsl #16
      24: f2c147a8     	movk	x8, #2621, lsl #32
      28: f2f47ae8     	movk	x8, #41943, lsl #48
      2c: 9b487c08     	smulh	x8, x0, x8
      30: 8b000108     	add	x8, x8, x0
      34: d37ffd09     	lsr	x9, x8, #63
      38: d346fd08     	lsr	x8, x8, #6
      3c: 0b090108     	add	w8, w8, w9
      40: 52800c89     	mov	w9, #100
      44: 1b098108     	msub	w8, w8, w9, w0
      48: 340000c8     	cbz	w8, 0x60 &lt;_main+0x58&gt;
      4c: 1b087d08     	mul	w8, w8, w8
      50: f90003e8     	str	x8, [sp]
      54: 90000000     	adrp	x0, 0x0 &lt;_main+0x4c&gt;
		0000000000000054:  ARM64_RELOC_PAGE21	l_.str
      58: 91000000     	add	x0, x0, #0
		0000000000000058:  ARM64_RELOC_PAGEOFF12	l_.str
      5c: 94000000     	bl	0x5c &lt;_main+0x54&gt;
		000000000000005c:  ARM64_RELOC_BRANCH26	_printf
      60: 90000000     	adrp	x0, 0x0 &lt;_main+0x58&gt;
		0000000000000060:  ARM64_RELOC_PAGE21	l_.str.1
      64: 91000000     	add	x0, x0, #0
		0000000000000064:  ARM64_RELOC_PAGEOFF12	l_.str.1
      68: 94000000     	bl	0x68 &lt;_main+0x60&gt;
		0000000000000068:  ARM64_RELOC_BRANCH26	_puts
      6c: 52800000     	mov	w0, #0
      70: a9417bfd     	ldp	x29, x30, [sp, #16]
      74: 910083ff     	add	sp, sp, #32
      78: d65f03c0     	ret
</code></pre> <p>But if we use the instruction <code class="language-plaintext highlighter-rouge">if(unlikely(i))</code> the assembly generated is:</p> <pre><code class="language-assembly">
test_likely.o:	file format mach-o arm64

Disassembly of section __TEXT,__text:

0000000000000000 &lt;ltmp0&gt;:
       0: 1b007c00     	mul	w0, w0, w0
       4: d65f03c0     	ret

0000000000000008 &lt;_main&gt;:
       8: d10083ff     	sub	sp, sp, #32
       c: a9017bfd     	stp	x29, x30, [sp, #16]
      10: 910043fd     	add	x29, sp, #16
      14: d2800000     	mov	x0, #0
      18: 94000000     	bl	0x18 &lt;_main+0x10&gt;
		0000000000000018:  ARM64_RELOC_BRANCH26	_time
      1c: d29ae168     	mov	x8, #55051
      20: f2ae1468     	movk	x8, #28835, lsl #16
      24: f2c147a8     	movk	x8, #2621, lsl #32
      28: f2f47ae8     	movk	x8, #41943, lsl #48
      2c: 9b487c08     	smulh	x8, x0, x8
      30: 8b000108     	add	x8, x8, x0
      34: d37ffd09     	lsr	x9, x8, #63
      38: d346fd08     	lsr	x8, x8, #6
      3c: 0b090108     	add	w8, w8, w9
      40: 52800c89     	mov	w9, #100
      44: 1b098108     	msub	w8, w8, w9, w0
      48: 35000108     	cbnz	w8, 0x68 &lt;_main+0x60&gt;
      4c: 90000000     	adrp	x0, 0x0 &lt;_main+0x44&gt;
		000000000000004c:  ARM64_RELOC_PAGE21	l_.str.1
      50: 91000000     	add	x0, x0, #0
		0000000000000050:  ARM64_RELOC_PAGEOFF12	l_.str.1
      54: 94000000     	bl	0x54 &lt;_main+0x4c&gt;
		0000000000000054:  ARM64_RELOC_BRANCH26	_puts
      58: 52800000     	mov	w0, #0
      5c: a9417bfd     	ldp	x29, x30, [sp, #16]
      60: 910083ff     	add	sp, sp, #32
      64: d65f03c0     	ret
      68: 1b087d08     	mul	w8, w8, w8
      6c: f90003e8     	str	x8, [sp]
      70: 90000000     	adrp	x0, 0x0 &lt;_main+0x68&gt;
		0000000000000070:  ARM64_RELOC_PAGE21	l_.str
      74: 91000000     	add	x0, x0, #0
		0000000000000074:  ARM64_RELOC_PAGEOFF12	l_.str
      78: 94000000     	bl	0x78 &lt;_main+0x70&gt;
		0000000000000078:  ARM64_RELOC_BRANCH26	_printf
      7c: 17fffff4     	b	0x4c &lt;_main+0x44&gt;
</code></pre> <p>We can see the difference in printf function here. The printf function is pushed after the instruction puts in second example when <code class="language-plaintext highlighter-rouge">unlikely</code> keyword was used.</p> <p>These are just small examples but in bigger codebase, using these likely and unlikely keywords can improve the performance significantly</p> <h2 id="return-on-address-instructions">Return On Address Instructions</h2> <p>Another such instruction to predict control flow of the code is return on address instruction. This instruction is used in functions. Since function defined can be called anywhere from the code, it’s hard to predict the address from which it was called. Thus, return jump can be hard to predict before execution and thus making pipeline flush.</p> <p>There is a stack called “Return Address Stack” in hardware, which is a predictor to predict the return of the functions. In GCC, we can know the return address using instruciton <code class="language-plaintext highlighter-rouge">__builtin_return_address</code>. This functions can be used as following code :</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span>
<span class="cp">#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)
</span>
<span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"return address to this square function is : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">ptr</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">num</span><span class="o">*</span><span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">square</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span><span class="o">%</span><span class="mi">100</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"value of i %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">"returning now</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>The output following code provides is :</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return address to this square function is : 0x1040c7ed4
value of i 7569
returning now
</code></pre></div></div> <h2 id="commands-used-to-generate-the-assembly-code-are">Commands used to generate the assembly code are:</h2> <ol> <li><code class="language-plaintext highlighter-rouge">gcc -c -O3 -std=gnu11 test_likely.c</code> gcc command is used to compile the code and generate the code in machine level language. O3 flag shows that optimization level is 3. There are total 4 levels of optimization levels in gcc (from 0-3) with third being highest.</li> <li><code class="language-plaintext highlighter-rouge">objdump -dr test_likely.o</code> objdump command does object dump and parameters dr are used to disassemble the machine code in assembly.</li> </ol> <h2 id="references">References</h2> <ol> <li>Book : Computer Architecture: A Quantitative Approach (The Morgan Kaufmann Series in Computer Architecture and Design) 5th edition</li> <li>https://stackoverflow.com/questions/109710/how-do-the-likely-unlikely-macros-in-the-linux-kernel-work-and-what-is-their-ben</li> <li>https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html</li> </ol>]]></content><author><name></name></author><summary type="html"><![CDATA[example of branch prediction with customizations]]></summary></entry></feed>